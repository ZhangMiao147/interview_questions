# 收集的字节跳动的面试题

https://www.nowcoder.com/discuss/470478

1. 介绍一下 https，CA证书客户端是如何校验的？ 

   https 是 SSL/TLS+HTTP，是有加密功能的网络通信协议。

2. 讲解一下你在项目中使用的设计模式？单例中使用枚举的实现原理有过了解么？通过静态内部类实现的单例有啥优点？通过返回自身实现的设置属性同builder模式有什么不一样？

   项目中使用了观察者模式和工厂模式。

   观察者模式是观察者观察被观察者的某一项变化，被观察者在状态变化的时候通知观察者。项目中有个功能是题目作答完成之后回去将题好变为绿色，表示该道题已完成，在所有空格输入完成或者选择题选了选项的都是会通知。

   工厂模式是在题目解析中使用的，有一个总工厂根据题目的不同数据使用试卷工厂或者题目工厂创建题目布局。

   静态内部类实现的单例对象会在需要的时候才创建对象。

3. 介绍一下classloader的实现原理，讲解一下项目中热修复的实现原理？

   

4. 介绍一下Android资源文件R.id的生成规则？

5. 介绍一下注解，并介绍一下你在项目中使用注解的时候。

   注解是一种标识。

   常用的注解就是 @Overrid 表示复写父类方法，@ResId 表示这个参数是 R.id 的数据。

6. 介绍一下动态代理，并说一下在哪里使用过。

   动态代理是不用实现代理对象的接口，使用 Proxy.proxy 方法，在 InvoteHandler 的 invoke 方法中处理请求方法。

   Retrofit 里面有使用动态代理。

7. 讲解一下自定义 view 的流程

   自定义 View 主要是复写三个方法， onMeasure()、onLayout()、onDraw() 方法。

   onMeasure() 方法是测量 View 的宽高。

   onLayout() 方法是计算 view 的布局。

   onDraw() 方法是绘制 view 的显示。

8. 介绍一下啊livedata的实现原理

https://www.nowcoder.com/discuss/446973

一面： 

 1、首先是自我介绍（需要注意的地方：说有亮点的、跳槽原因，从各个点尽力彰显自己优势、技术特长） 



 2、手写代码：计算View树上所有view的数量，参数ViewGroup（本质上就是数据结构多叉树递归层序遍历+Android View基本api调用） 

 ```java
   public int getViewCount(ViewGroup viewGroup) {
        int childCount = viewGroup.getChildCount();
        int count = 0;
        for (int i = 0; i < childCount; i++) {
            View child = viewGroup.getChildAt(i);
            if (child instanceof ViewGroup) {
                count += getViewCount((ViewGroup) child);
            } else {
                count++;
            }
        }
        return count;
    }
 ```

 Android相关 

 3、主线程Looper一直循环查消息为何没卡主线程？ 

 （1）线程的阻塞状态（Blocked）：阻塞状态是线程因为某种原因放弃CPU使用权，暂时停止运行。直到线程进入就绪状态，才有机会转到运行状态。 

 （2）主线程Looper从消息队列读取消息，当读完所有消息时，主线程阻塞。子线程往消息队列发送消息，并且往管道文件写数据，主线程即被唤醒，从管道文件读取数据，主线程被唤醒只是为了读取消息，当消息读取完毕，再次睡眠。因此loop的循环并不会对CPU性能有过多的消耗。 

  

 4、RecyclerView相对ListView区别？ 

 （1）从布局效果上 

RecyclerView 可以实现的效果更加丰富，根据 LayoutManager 的不同可以实现线性布局和网格布局，而 ListView 只能实现线性布局。

 （2）从缓存机制上 

RecyclerView 有四层缓存，RecyclerView 缓存的是 ViewHolder，而 List 只是缓存 View。

 5、Bitmap resize相关，设置option，decode 

 6、用MultiDex解决何事？其根本原因在于？Dex如何优化？主Dex放哪些东西？主Dex和其他Dex调用、关联？Odex优化点在于什么？ 

 答：MultiDex解决方法数65535的限制问题，即方法数不能超过65535个；方法id是short类型4个字节来存储的，所以数目范围应在0-2^32即0-65535；MultiDex工作原理分析和优化方案; 主dex中：应用启动就必须加载的类，有一个[keep]()文件来控制；其他dex文件都是通过主dex加载进来的；odex优化点：预加载； 

 7、Dalvik和Art虚拟机区别？ 

 9、多渠道打包如何实现(Flavor、Dimension应用)？从母包生出渠道包实现方法？渠道标识替换原理？ 

 10、Android打包哪些类型文件不能混淆？ 

四大组件的类，

引用的开源包指定的文件不加混淆。

 11、Retrofit主要实现机制？ Retrofit的作用、原理 

Retrofit 的主要实现机制是动态代理。通过动态代理创建请求的参数，请求的解析等。

Retrofit 主要是对网络请求的封装，网络请求使用的是 OkHttp，可以设置请求结果解析和流程控制。

Retrifit 通过动态代理将请求方法进行解析，网络请求通过 OkHttp 实现，得到请求结果后，使用设置的解析结果工具将结果解析，然后将请求状态传递给流程控制器。

 12、动态代理静态代理区别？ 

静态代理的目标类需要实现代理类，而动态代理不需要实现代理类。

 13、模块化怎么做？怎么设计？接口发现暴漏怎么做？基于什么基本思想？ 



 14、MVC、MVP、MVVM应用和彼此本质区别？ 

  MVC:Mode-View-Controller，Model 负责数据，对应网络请求，View 负责页面，对应 xml 布局文件，Controller 负责逻辑控制，对应 Activity，但是 xml 的布局能力太弱，所以 Activity 既要负责 Controller 和 View，会导致代码很多。

MVP：Mode-View-Presenter，Presenter 负责Mode 和 View 之间的通信，Mode 负责数据，对应网络请求，View 负责页面，对应 Activity 和 xml 布局文件，Presenter 负责调用 mode 请求数据和将请求结果反馈给 View，这样会导致 数据不同变化要调用 View 的不同方法，导致 View 的方法特别多。

MVVM：Mode-View-ViewModel，ViewModel 负责 Mode 和 View 之间的通信，通过 DataBinding 减少了 Activity 对 View 的处理。

 二面： 

 1、Glide缓存特点 

Glide 的缓存有两部分，一是内存缓存，用来防止同样的 Bitmap 加载进内存中，使用的是 LruCache 做缓存，而是硬件缓存，用来防止对统一格式的数据从网络上重复下载。

 2、问了擅长哪个方向？回答UI动画，所以就问UI相关的 

 （1）launcher应用抽屉，之前有个毛玻璃效果背景，从系统ROM角度说下怎么做？ 

 （2）实时的睡眠水面倒影效果怎么做？ 实时更新的UI性能如何保证？ 

 （3）UI基础：Measure、Layout、draw大流程、绘制顺序，FlowLayout怎么实现？  

  3、算法题：两个线程分别持续打印奇数和偶数，实现两个线程的交替打印（从小到大） 

使用 volatile 和 synchronized 实现

```java
public static class NumThread1 {
    private volatile int count = 1; // 可以使用 AutomInteger
    private int max = 100;

    public void showCount() {
        Thread A = new Thread(new CountA());
        Thread B = new Thread(new CountB());
        A.start();
        B.start();
    }

    public class CountA implements Runnable {

        @Override
        public void run() {
            while (count <= max) {
                synchronized (NumThread1.class) {
                    if (count <= max && count % 2 == 1) {
                        System.out.println(count++);
                    }
                }
            }
        }
    }

    public class CountB implements Runnable {

        @Override
        public void run() {
            while (count <= max) {
                synchronized (NumThread1.class) {
                    if (count <= max && count % 2 == 0) {
                        System.out.println(count++);
                    }
                }
            }
        }
    }
}
```

使用 syncrhonzied + volatile+wait+notify 实现：

```java
    // synchronized+wait+notify
    public static class NumThread2 {
        private volatile int count = 1;
        private int max = 100;
        private Object oneObject = new Object();
        private Object twoObject = new Object();

        public void showCount() {
            Thread A = new Thread(new CountA());
            Thread B = new Thread(new CountB());
            A.start();
            B.start();

        }

        public class CountA implements Runnable {

            @Override
            public void run() {
                while (count <= max) {
                    if (count % 2 == 0) {
                        synchronized (oneObject) {
                            try {
                                oneObject.wait();
                            } catch (InterruptedException e) {
                                e.printStackTrace();
                            }
                        }
                    } else {
                        System.out.println(count++);
                        synchronized (twoObject) {
                            twoObject.notify();
                        }
                    }
                }
            }
        }

        public class CountB implements Runnable {

            @Override
            public void run() {
                while (count <= max) {
                    if (count % 2 == 1) {
                        synchronized (twoObject) {
                            try {
                                twoObject.wait();
                            } catch (InterruptedException e) {
                                e.printStackTrace();
                            }
                        }
                    } else {
                        System.out.println(count++);
                        synchronized (oneObject) {
                            oneObject.notify();
                        }
                    }
                }
            }
        }
    }
```

ReentrantLock 实现：

```java
public static class NumThread3 {
        private AtomicInteger count = new AtomicInteger(1);
        private ReentrantLock reentrantLock = new ReentrantLock();
        private Condition one = reentrantLock.newCondition();
        private Condition two = reentrantLock.newCondition();
        private int max = 100;

        public void showCount() {
            Thread threadA = new Thread(new CountA());
            Thread threadB = new Thread(new CountB());
            threadA.start();
            threadB.start();
        }


        public class CountA implements Runnable {
            @Override
            public void run() {
                while (count.get() <= max) {
                    reentrantLock.lock();
                    try {
                        if (count.get() % 2 == 0) {
                            one.await();
                        }
                        if (count.get() <= max) {
                            System.out.println(count.getAndIncrement());
                        }
                        two.signal();
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    } finally {
                        reentrantLock.unlock();
                    }
                }
            }
        }

        public class CountB implements Runnable {
            @Override
            public void run() {
                while (count.get() <= max) {
                    reentrantLock.lock();
                    try {
                        if (count.get() % 2 == 1) {
                            two.await();
                        }
                        if (count.get() <= max) {
                            System.out.println(count.getAndIncrement());
                        }
                        one.signal();
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    } finally {
                        reentrantLock.unlock();
                    }
                }
            }
        }

    }
```

flag 实现

```java
    public static class NumThread4 {
        private AtomicInteger count = new AtomicInteger(1);
        private boolean flag = false;
        private static int MAX = 100;

        public void showCount() {
            Thread threadA = new Thread(new CountA());
            Thread threadB = new Thread(new CountB());
            threadA.start();
            threadB.start();
        }

        public class CountA implements Runnable {
            @Override
            public void run() {
                while (count.get() <= MAX) {
                    if (flag) {
                        System.out.println(count.getAndIncrement());
                        flag = !flag;
                    }
                }
            }
        }

        public class CountB implements Runnable {
            @Override
            public void run() {
                while (count.get() <= MAX) {
                    if (!flag) {
                        System.out.println(count.getAndIncrement());
                        flag = !flag;
                    }
                }
            }
        }

    }
```



 4、模块化、工程化架构思想 

  

 三面： 

 1、设计个IM客户端以及数据库架构，类似微信，偏上层业务部分的会话、联系人、通知、 

 2、公众号如何存、分几张表，架构每一层都是什么，互相怎么交互工作？



https://www.nowcoder.com/discuss/437442

1.替换多重嵌套的if else写法； 

 2.private和static修饰的方法可以重写吗； 

都不可以，private 是私有方法，只有当前对象可以调用，static 表示是类的方法而不是对象的方法。

 3.类A私有变量i，类B继承A私有变量j，构造方法带各自的变量，哪个编译成功； 

 4.arraylist,linkedlist,vector效率； 

arrayList 是数组结构，访问与修改效率很高，插入和删除需要移动数据，效率不高。

linkedList 是链表结构，访问和修改都需要遍历寻找位置，头插的时间复杂度只需要 O(1)，中间插入和尾插效率不高，也是需要遍历寻找位置，删除和插入一样。



 5.写一个单例； 

```java
public class Single {
    /**
     * 懒汉模式，线程不安全
     * 这种方式是最基本的实现方式，这种实现最大的问题就是不支持多线程。因为没有加锁 synchronized，所以严格意义上它并不算单例模式。
     * 这种方式 lazy loading 很明显，不要求线程安全，在多线程不能正常工作。
     */
    public static class Single1 {
        private static Single1 instance;

        private Single1() { }

        public static Single1 getInstance() {
            if (instance == null) {
                instance = new Single1();
            }
            return instance;
        }
    }

    /**
     * 饿汉模式，线程安全
     * 这种方式比较常用，但容易产生垃圾对象。 　　
     * 优点：没有加锁，执行效率会提高。 　　
     * 缺点：类加载时就初始化，浪费内存。 　　
     * 它基于 classloder 机制避免了多线程的同步问题，不过，instance 在类装载时就实例化，虽然导致类装载的原因有很多种，在单例模式中大多数都是调用 getInstance 方法，
     * 但是也不能确定有其他的方式（或者其他的静态方法）导致类装载，这时候初始化 instance 显然没有达到 lazy loading 的效果。
     */
    public static class Single2 {
        private static Single2 instance = new Single2();

        private Single2() { }

        public static Single2 getInstance() {
            return instance;
        }
    }

    /**
     * 线程安全,双重锁
     * 这种方式采用双锁机制，安全且在多线程情况下能保持高性能。
     * getInstance() 的性能对应用程序很关键。
     */
    public static class Single3 {
        private volatile static Single3 instance;

        private Single3() { }

        public static Single3 getInstance() {
            if (instance == null) {
                synchronized (Single3.class) {
                    if (instance == null) {
                        instance = new Single3();
                    }
                }
            }
            return instance;
        }
    }

    /**
     * 静态内部类
     * 这种方式能达到双检锁方式一样的功效，但实现更简单。
     * 对静态域使用延迟初始化，应使用这种方式而不是双检锁方式。
     * 这种方式只适用于静态域的情况，双检锁方式可在实例域需要延迟初始化时使用。
     * 这种方式同样利用了 classloder 机制来保证初始化 instance 时只有一个线程，
     * 它跟饿汉模式方式不同的是：饿汉模式方式只要 Singleton 类被装载了，那么 instance 就会被实例化（没有达到 lazy loading 效果），
     * 而这种方式是 SingletonHolder 类被装载了，instance 不一定被初始化。因为 SingletonHolder 类没有被主动使用，只有显示通过调用 getInstance 方法时，
     * 才会显示装载 SingletonHolder 类，从而实例化 instance。想象一下，如果实例化 instance 很消耗资源，所以想让它延迟加载，
     * 另外一方面，又不希望在 Singleton 类加载时就实例化，因为不能确保 Singleton 类还可能在其他的地方被主动使用从而被加载，那么这个时候实例化 instance 显然是不合适的。
     * 这个时候，这种方式相比饿汉模式方式就显得很合理。
     */
    public static class Single5 {

        private static class SingleHolder {
            private static final Single5 instance = new Single5();
        }

        private Single5() { }

        public static final Single5 getInstance() {
            return SingleHolder.instance;
        }
    }


    /**
     * 懒汉模式，线程安全
     * 这种方式具备很好的 lazy loading，能够在多线程中很好的工作，但是，效率很低，99% 情况下不需要同步。 　　
     * 优点：第一次调用才初始化，避免内存浪费。 　　
     * 缺点：必须加锁 synchronized 才能保证单例，但加锁会影响效率。getInstance() 的性能对应用程序不是很关键（该方法使用不太频繁）。
     */
    public static class Single6{
        private static Single6 instance;
        private Single6(){}
        public static synchronized Single6 getInstance(){
            if (instance == null){
                instance = new Single6();
            }
            return instance;
        }

    }

    /**
     * 枚举
     *
     * 这种实现方式还没有被广泛采用，但这是实现单例模式的最佳方法。它更简洁，自动支持序列化机制，绝对防止多次实例化。
     * 这种方式是 Effective Java 作者 Josh Bloch 提倡的方式，它不仅能避免多线程同步问题，而且还自动支持序列化机制，
     * 防止反序列化重新创建新的对象，绝对防止多次实例化。
     * 不过，由于 JDK1.5 之后才加入 enum 特性，用这种方式写不免让人感觉生疏，在实际工作中，也很少用。 　　
     * 不能通过 reflection attack 来调用私有构造方法。
     */
    public enum Single7{
        INSTANCE;
        private void method(){

        }
    }
    /**
     * 一般情况下，不建议使用懒汉方式，建议使用第 3 种饿汉方式。
     * 只有在要明确实现 lazy loading 效果时，才会使用静态内部类登记方式。
     * 如果涉及到反序列化创建对象时，可以尝试使用枚举方式。如果有其他特殊的需求，可以考虑使用双检锁方式。
     */
}

```



 6.比较string="aaa"和string=new string("aaa")。 

 \7. EventBus是如何实现事件通知的？ 

 \8. Glide的缓存？Glide是如何加载Gif图片的？ 

 \9. RecyclerView/ListView中的观察者模式



https://www.nowcoder.com/discuss/437053



面试过程或经历:主要把笔试内容分享出来希望能帮到后来的朋友。笔试总共有七个题目，分别是： 

 \1. hashmap实现原理； 

hashmap 是利用哈希表的思想来实现的。内部有一个数组，根据 key 的 hash 值将 value 放入 hash 值对应的数组的位置，如果发生哈希冲突，使用链表来解决。

hashMap 1.8 会使用 链表+红黑树来解决哈希冲突。

 2.自定义view的步骤； 

 3.给出一个activity的布局：activity里包含viewgroup1，viewgroup1里包含viewgroup2，viewgroup2里包含button，问touch事件的传递和处理机制； 

viewGroup1#dispatchTouchEvent() -> viewGroup1#onInterceptTouchEvent() -> viewGroup2# dispatchTouchEvent() -> viewGroup2#onInterceptTouchEvent() -> Button#dispatchToucheEvent() -> Button#onTouchEvent() -> ViewGroup2#onTouchEvent() -> ViewGroup1#onTouchEvent()。



4. Looper和handler的关系； 

5. activity从后台进程切换到前台经历的生命周期； 

   onReStart()->onResume()

 6.有两个数字非常大已经超出了long型的范围，现在以链表的方式存储其中链表头表示最高位，例如1->2->3->4表示1234，请设计一个算法求出两数之和；

将两个链表进行反转，然后进行相加处理。


链接：https://www.nowcoder.com/discuss/435701



***\*[字节跳动]()\**** 

 1面：主要问一些Java基础和Android基础。手写了一个二分查找算法。都是一些比较基础的问题。

 

 2面：上来先问了一些Android方面的问题，然后问想要自己实现一个加载图片的框架，应该怎么去实现。 

加载图片的框架：

1. 建立缓存

 3面：是主管面试，问了一遍要想实现加载图片框架应该怎么去实现，还有一个要实现上传日志的功能，应该怎么去实现，最后问了一个智力题：一共有4个球，其中一个球比较轻，如何测量两次把轻的球找出来。 

* 上传日志的功能

* 智力题

  问一下除了一个球轻，剩下的球的重量是不是相同的。

  如果是相同的，则将四个球分为两组，测量一次，然后将较轻的两个球再测量一次，较轻的一个球就是答案。


https://www.nowcoder.com/discuss/435260



***\*[字节跳动]()\**** 

 \1. 进程如何保活，怎样做才能让APP尽量不被杀死等。

进程保活的方法就是尽量提高进程的优先级。

方法有：

1. 在进程中发送前台通知。
2. 使用 JobService。
3. 使用 bindService 来开启一个守护进程，在断开绑定的时候进行拉活。

 \2. 问了两个算法题，一个是跳台阶的问题，另一个是链表判断是否有环。 

* 跳台阶问题

  跳台阶可以将问题分析为这个台阶是走一个台阶和走两个台阶的和。

* 链表判断是否有环

3. 为什么重写equals方法的时候也需要重写hashCode方法？ 

   因为对于一个对象 equals() 方法为 true 的时候，hashCode() 方法也要相同。

   hashMap 在根据 key 获取 value 的时候，会用 hashCode() 的值进行位运算得到 hash 值，在 hash 值相等的情况下，equals() 也相等，才会判断这个 key 是相同的

 \4. 问AsyncTask怎么用？ 

 \5. 事件分发，内存优化，性能优化。 

 \6. 问rgb_565位图，一个像素占多少位？ 

 \7. 问java内存GC原理。 

 \8. andoird lanucher的架构怎么样，用到什么模式。 

 \9. 做过什么android的应用。 

 \10. Android View的刷新机制。事件机制，内存机制。 

* Android View 的刷新机制

  每隔 16 ms 刷新一次。

* 事件机制

  

* 内存机制

11. Handler 机制问题. 进程共享数据. 

* Handler 机制问题
* 进程共享数据

 \12. 应用共享数据.， Layout的使用. 

* 应用共享数据
* Layout 的使用

 \13. 异步操作的方式. 



 \14. 传递数据的方式,主要是自定义的类需要继承的那个接口. 



 \15. JNI线程需要对java VM做的操作. 

 \16. UI性能优化 。 

 \17. 问冒泡算法的时间复杂度? java中的泛型?  

* 冒泡算法的时间复杂度

  冒泡算法的思想是：数组中的数据从头到尾两两进行比较，如果顺序是相反的，则将数据进行交换，这样一次遍历下来，最小的数据就会到数组的头部。

  如果数据刚好是有序的，只需要遍历一遍数据即可，如果数据是逆序，则需要 O(n^2)。
  
* 泛型

  



 \18. 对ios和Android怎么看以及发展前景 。 

我觉得 Android 的发展前景会更好，因为用户更加庞大，ios 系统比较好，而且和 iPad、MAC 配套使用很方便。

 \19. 问你觉得你的优点/缺点是什么？你为什么离开上一家公司？你未来5年内的职业规划是什么？

优点：

* 身体好，生病少，能抗的住强度工作。
* 喜欢自己从事的行业，喜欢搞技术。
* 性格好，能和同事友好相处。

缺点：

* 英语口语差。
* 审美差。

离开上一家公司的原因：

* 想要学习新技术。
* 深圳机会多。

未来 5 年内的职业规划：

* 向往架构师方向发展。

  

 \20. 问熟悉使用那种开发语言？对Android开发有没有经验？



***\*[字节跳动](https://www.nowcoder.com/jump/super-jump/word?word=字节跳动)\****

1.view的事件分发，事件分发问的比较深。



2.然后是view绘制的流程

3.tcp，udp，区别

tcp：基于字节流的可靠的套接字协议。

udp：基于事件的不可靠的事件协议。

区别：

1. tcp 是可靠的，在传输数据之前会进行三次握手建立连接，在传输数据之后会进行四次挥手断开连接。udp 是不可靠的，在传输数据时是直接发送数据的。
2. tcp 是基于子节流的，udp 是基于事件的。

4.三四次握手的问题

5.项目中遇到了哪些困难

6.为什么要离职



https://www.nowcoder.com/discuss/415011



一面

 

 1、java泛型，反射

泛型就是对于不同的对象，处理的逻辑是相同的，而这个不同的对象可以用泛型来表示。

反射就是可以通过对象的class对象调用对象的放啊。

 2、进程间通信的方式，安卓中有哪些方式，为什么是基于Binder的，不用传统的操作系统进程间通信方式呢

进程间通信方式：

* socket
* 文件
* Binder
* ContentProvider
* Messager

 3、一个app可以开启多个进程嘛，怎么做呢，每个进程都是在独立的虚拟机上嘛

可以，在 AnroidManifest 的四大组件的配置中加上android:process 即可。

Android 会为每一个进程分配独立的虚拟机。

https://www.jianshu.com/p/54d2983bea2c

 4、异步消息处理流程，如果发送一个延时消息，messagequeue里面怎么个顺序，messagequeue是个什么数据结构

messageQueue 根据 Message 的剩余时间进行排序。

MessageQueue 是使用链表来存储 Message 的。

 5、广播的种类，注册的方式，以及不同注册方式的生命周期。

广播分为有序广播和无序广播，有序广播是按照广播的优先级将消息进行传递，优先级高的广播可以停止广播的传递，无序广播是按照注册的顺序进行分发广播的。



 6、局部广播和全局广播的区别分别用什么实现的。



 7、activity和service的通信方式

Messager

 8、进程和线程的区别

进程与进程之间的数据是相互独立的，线程与线程之间的是共享的创建进程的资源。

线程由进程进行创建。

 9、并发和并行分别是什么意思，多线程是并发还是并行

并发指的是CPU 是独立的，各用各的。

并行的指公用一个 CPU，轮流抢占 CPU 资源。

多线程是并行。

 10、安卓11有什么新的特性。

 11、HTTPS过程。

第一步，进行证书的验证。

第二步，进行三次握手建立连接。

第三步，进行数据传输。

第四步，四次挥手断开连接。

 12、DNS解析过程，如果服务器ip地址改变了，客户端怎么知道呢

DNS 解析过程是先从本地缓存中读取，本地缓存没有从本地浏览器读取，没有从 hosts 文件中读取，如果还是没有从局域网缓存中读取，没有就向服务商请求。

 13、算法：二叉树的右视图。

 

 二面

 

 1、介绍一下所有的map，以及他们之间的对比，适用场景。

HashMap：使用数组+链表实现的哈希表。使用于普通的场景。

TreeMap：使用红黑树实现的哈希表。如果数据量比较大，并且查找频繁，则使用。

LinkedHashMap：有序的哈希表。使用有顺序要求，则使用 LinkedHashMap。



 2、一个按钮，手抖了连续点了两次，会跳转两次页面，怎么让这种情况不发生。

https://www.jianshu.com/p/dc63a4b636fa

按钮点击后就设置 enable 为 false。

根据上一次点击的时间，计算两次点击的时间间隔，时间间隔太小，就不响应。

页面的 Activity 设置为 singTop 启动模式。

 3、一个商品页一个商详页，点击商详页的一个关注按钮，希望回- 到商品页也能够显示关注的状态，怎么做

 4、项目中定时为什么用AlarmManager，不用postDelayed

 5、项目中后台网络请求为什么用service不用线程

Service 有生命周期的控制，方便开启和关闭。

线程开启后，无法及时控制。

 6、安卓的新特性。

 7、内部类会有内存泄漏问题吗 内部类为什么能访问外部类的变量，为什么还能访问外部类的私有变量。

内部类会持有外部类的一个对象引用，所以内部类能访问外部类的变量。

？

 8、算法: 单链表判断有无环。

 

 三面

 

 1、介绍项目用到了contentprovider,然后问ContentProvider的生命周期，application,activity，service,contentprovider他们的 context有什么区别。

ContentProvider 有 onCreate()、insert()、delete()、改查 、update() 生命周期方法。

Application 的 context 的生命周期是最长的，和应用的生命周期一样长。

activity 的 context 的生命周期随 Activity 的创建和销毁变化。

 2、内存溢出和内存泄漏，提到了bitmap



 3、然后问下载一个图片的时候直接下载了一个5g的图片，不压缩一定会产生OOM问题，那么怎么去获取这个图片的长宽呢，或者说这个图片的大小的大小在你没下载之前如何得到。

图片的大小是 5g，然后看图片的格式是什么，判断出图片的一个像素是多大，然后就可以得到图片的像素大小。



***\*[字节跳动](https://www.nowcoder.com/jump/super-jump/word?word=字节跳动)\****

1.view的事件分发，事件分发问的比较深。

onInteceptTouchEvent() 分发事件

dispatchTouchEvent() ViewGroup 拦截事件

onTouchEvent() 处理事件



2.然后是view绘制的流程

View 的绘制只要涉及到三个方法：onMeasure() 、onLayout()、onDraw()。

onMeasure() 方法是负责view宽高的测量的。

onLayout() 方法负责 view 的布局确定。

onDraw() 方法负责绘制 view。

3.tcp，udp，区别

tcp 和 udp 都是传输层的协议，负责向 ip 传送数据。

tcp 基于字节流的套接字协议，是安全的。

udp 基于事件的协议，是不安全的。

4.三四次握手的问题

tcp 在传输数据之前建立连接会进行三次握手，在数据传输完毕，会通过四次挥手进行断开连接。

三次握手的过程是：第一次握手：客户端发送 syn M 包到服务器，服务器检测客户端发过来的包标志为 syn 知道这是客户端请求连接。第二次握手：服务器发送 syn N，ack M+1 的包给客户端，客户端接收到服务器，检测包有 ack M+1 就知道服务器收到了上一个包。第三次握手：客户端向服务器发送 ack N+1 的消息给服务器，服务器接收到包后，知道客户端接收到了确认包。

三次握手完成，客户端和服务器之间就开始发送数据。

四次挥手：第一次挥手：客户端在不再会向服务器发送数据的时候，向服务器发送一个 FIN n 的数据包，服务器接收到包之后就会知道客户端不会再发送数据过来了。第二次挥手：服务器会先给客户端发送一个 ack n+1 的确认包，客户端接收后，确定服务器已经接收到数据，这个时候，客户端还是可以接收服务器发送过来的数据的。第三次挥手：服务器的工作处理完成后，向客户端发送一个 FIN m 的包，客户端接收后确定服务器也可以断开连接了。第四次挥手：客户端向服务器发送 ACK m+1 的确认包，服务器接收后断开连接，客户端在等待一个请求响应的时间后断开连接。

5.项目中遇到了哪些困难

前一段时间写在线考试的功能，学生作答的图片上传到阿里的 oss，把图片上传上去之后，根据规则将图片的链接拼好后，使用 Glide 显示图片失败，提示说是没有匹配的 adapter。

然后就上网查，找资料，看了一下 Glide 的源码，自定义了 Glide 的解析器解决了问题。

6.为什么要离职




https://www.nowcoder.com/discuss/369400



1 面 1h 多（具体多了多少分钟忘了） 

  1.算法题 两个栈实现队列 

  2.算法题 输入一个数组，想一种方法让这个数组尽可能的乱序，保证功能能实现的情况下时间复杂度和空间复杂度尽可能的小，可使用随机数函数。（面试官最后说了 O(n)的时间复杂度能实现） 

  3.写一个单例（自己写一种就行） 



  4.ActivityA -> Activity B -> Activity A 

  Activity A 启动模式为 singleTask 

  Activity B 启动模式为常规模式 

  问  A 启动 B，B 又启动 A 的生命周期调用顺序？ 

A onCreate() -> A onStart() -> A onResume() -> B   onCreate() -> B onStart() -> B onResume() -> A onPause() -> A onStop() -> A onNewInstance()。

  5.你刚才提到  onsaveinstancestate() ，说一下调用时机，它用来干什么的。 

在 onPause() 之后回调，与 onStop() 的顺序不确定，在 Activity 异常退出或者配置改变的时候回调，用于保存 Activity 的当前状态。

  \6. onsaveinstancestate() 保存的那个参数叫什么？Bundle 里面都放一些什么东西？怎么实现序列化？Parcelable 和 Serializable 有什么区别？ 

  Bundle 。 

Bundle 里面可以放 基本数据结构和 String 还有 序列化对象，以及这些的数组类型。

通过 Parcelable 和 Serizable 实现序列化。

Parcelable 是 Android 特有的实现序列化的方式，实现比较麻烦，需要实现 CREATOR 对象，效率高。

Serializable 是 JDK 实现序列化的方法，实现简单，只需要实现 Serializable 接口即可，效率低。

  7.数组和链表的区别 



  8.HashMap 的结构以及原理 

  9.我看你简历上写了 retrofit，你能说一下它是做什么的，如果知道基本框架也说一下 

  10.了解 View 的绘制机制吗，能说一下吗 

  11.我看你项目里用的 Fragment 能说一下 Fragment A 启动了 Fragment B，Fragment B 中按下返回键只退出 Fragment B 怎么实现。 

通过 addFragment() 添加 Fragment ，并且调用 addBackStack() 方法将 Fragment A 加入到回退栈中。

  12.你还有什么要问的吗？ 

###   



  1.算法题 一个字符串，求最长没有重复字符的字符串长度 



  2.string stringbuffer 和 stringbuilder 区别 

StringBuffer 是线程安全的。StringBuilder 是非线程安全的。

  3.final finally finalize区别 

final 可以作用于类，方法，变量，作用于类，该类不能被其他类继承，作用于方法，子类不能复写该方法，作用于变量，变量只能初始化一次。

finally 是 try-catch 捕获异常的时候使用的，在try - catch 中 try 运行完一定会执行 finally() 中的代码，用于一些资源的释放。

finalize 

  \4. 数组和链表的区别 

数组的查找与修改很快，只需要 O(1) 的时间复杂度，插入和删除需要移动数组，需要 O(n) 的时间复杂度。

链表的查找和修改都需要遍历查找位置，需要 O(n) 的时间复杂度，头插很快，只需要 O(1) 的时间复杂度，插入其他位置需要遍历查找位置，需要 O(n) 的时间复杂度。删除和插入是一样的。

数组的初始空间大小是固定的，如果数据量很小，就会造成内存的浪费，在存放不下的时候会进行扩容。而链表的内存浪费主要是在链表的每一个节点都包含一个指向下一个节点的地址。

5.HashMap 了解过吗  



  6.Tcp 三次握手四次挥手


  https://www.zhihu.com/question/24853633，那种拿着打电话类似的答案就不要看了，那些高赞我感觉讲得很好，从原理上讲就印象深刻。

  7.get 与 post 的区别 

get是获取数据，不会涉及到数据库数据的更改，对数据库来说是安全的。传递的数据会在 url 中，对请求参数来说是不安全的。

post 是提交数据，传递的数据会存在请求体中，对传递的参数来说是安全的，post 会涉及到数据库数据的修改，对于数据库数据来说是不安全的。

  https://www.zhihu.com/question/28586791，大宽宽答主讲的很好，就是有点深奥，记一下 “浏览器的 GET 和 POST”、“接口中的 GET 和 POST” 就行。

  8.synchronized 的作用 

synchronized 是同步，保证了这个对象或者代码块在同一时间只有一个线程运行。

  9.你知道哪些设计模式 

单例模式：保证整个应用类只有一个对象。像是学生信息的类就是一个单例对象，里面存储学生id之类的信息。

观察者模式：观察者观察被观察者的某个状态，在被观察者状态变化的时候通知观察者。比如 Activity 观察题目的作答情况，在题目作答情况变化的时候通知 Acitivty，修改题号的布局显示。

工厂模式：



  10.Android 进程通信的方法 

Socket

文件

Bundler

Messager

AIDL

ContentProvider

  11.那你能说一下 Intent 是怎么进程通信的 



  12.内存泄漏有哪几种情况 

内存泄漏指的是一个对象已经使用完毕，但是有其他对象持有这个对象的引用，导致对象不能及时释放。

内部类持有外部类的对象，外部类对象释放的时候，内部类没有释放，倒是外部类无法释放。

资源没有释放，导致的内存泄漏，比如说 cursor 。



  13.有什么要问的吗

如果可以有幸进入公司，我进的是哪个部门哪个组，项目是什么？

项目组的 Android 开发有多少人？

现在项目使用的技术有哪些？



https://www.nowcoder.com/discuss/371130

一面 

 1，请编程实现单例模式，懒汉和饱汉写法 

 2，请编程实现Java的生产者-消费者模型 



 3，HashMap的内部结构？ 内部原理? 

HashMap 的内部结构是数组+链表，数组是存储哈希表，链表用来解决哈希冲突，JDK 1.8 的内部结构变成了数组+链表+红黑树，链表和红黑树都是为了解决哈希冲突，在链表数据量比较大的时候，会将链表转为红黑树。

内部原理：根据 key 计算出 hash 值，根据 hash 值计算得到 key 在数组中的位置，然后将 value 存储到数组位置的链表中。

 4，请简述Android事件传递机制， ACTION_CANCEL事件何时触发？ 



 5，Android的进程间通信，Liunx操作系统的进程间通信。 

Android 进程间通信：socket、文件、Bundler、AIDL、Messager、ContentProvider。

Linux 操作系统的进程间通信：socket、文件、pipe(管道)。

 6，JVM虚拟机内存结构，以及它们的作用。 
 这个问题也比较基础，JVM的内存结构如下图所示。 

JVM 虚拟机的内存结构有：程序计数器，虚拟机栈，本地方法栈，堆、方法区。

程序计数器：用来记录指令进行到那一行了。内存很小。

虚拟机栈：用于执行方法时将方法进行入栈，方法执行完毕后，将方法进行出栈，维持运行的顺序。一个对象的引用会存储在这里，而对象的内容存储还是会在堆中。

本地方法栈：是用于执行本地方法用的内存。

堆：用于分配静态变量，静态数据的内存。

方法区：执行方法使用的内存。

 7，简述Android的View绘制流程，Android的wrap_content是如何计算的。 

wrap_content 会根据父控件的属性结合计算。

父控件的 spec 是 AT_MOST，那么 wrap_content 也会是 AT_MOST，父控件是 EXECTET ，那么 wrap_content 也就是 EXECTED。

 8，有一个整形数组，包含正数和负数，然后要求把数组内的所有负数移至正数的左边，且保证相对位置不变，要求时间复杂度为O(n), 空间复杂度为O(1)。例如，{10, -2, 5, 8, -4, 2, -3, 7, 12, -88, -23, 35}变化后是{-2, -4，-3, -88, -23,5, 8 ,10, 2, 7, 12, 35}。 



 二面 

 1，bundle的数据结构，如何存储，既然有了Intent.putExtra，为啥还要用bundle。 
 2，android的IPC通信方式，是否使用过 
 3，Android的多点触控如何传递 核心类 
 4，asynctask的原理 AsyncTask是对Thread和Handler的组合包装。 
 5，android 图片加载框架有哪些，对比下区别 
 6，图片框架的一些原理知识 
 7，其他的一些Android的模块化开发，热更新，组件化等知识。 

 三面、主流框架 

 \1. EventBus 
 （1）EventBus是通过注解+反射来进行方法的获取的 
 （2）使用ConcurrentHashMap来保存映射关系 调用实体的构建：调用实体中对于Object，也就是实际执行方法的对象不应该使用强引用而是应该使用弱引用，因为Map的static的，生命周期有可能长于被调用的对象，如果使用强引用就会出现内存泄漏的问题。 
 （3）方法的执行 使用Dispatcher进行方法的分派，异步则使用线程池来处理，同步就直接执行，而UI线程则使用MainLooper创建一个Handler，投递到主线程中去执行。 

 2.Retrofit 
 Java中的动态代理 
 Retrofit中的动态代理 
 Retrofit作用 

 3.OkHttp 
 请求任务队列 
 复用连接池 

 \4. RxJava